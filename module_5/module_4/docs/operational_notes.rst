Operational Notes
=================

This page describes the operational behavior of the Module 4 application,
including the busy‑state policy, idempotency strategy, uniqueness
considerations, and common troubleshooting steps for local and CI
environments.

Busy-State Policy
-----------------

The application uses a simple busy‑state flag implemented in
``state.py``. Its purpose is to prevent overlapping operations during
``/pull-data`` and ``/update-analysis``.

- ``is_busy()`` returns whether an operation is in progress.
- ``set_busy(True)`` marks the system as busy.
- ``set_busy(False)`` marks the system as idle.

The busy flag ensures:

- Only one data pull can run at a time.
- Analysis cannot be recomputed while a pull is active.
- Tests can reliably assert correct sequencing of operations.

Because Module 4 runs in a single-threaded environment, no concurrency
primitives (locks, semaphores) are required.

Idempotency Strategy
--------------------

The application does not implement full idempotency because the
assignment uses an in‑memory list instead of a real database. However,
the following behaviors support predictable operation:

- ``insert_rows()`` appends rows exactly as provided.
- The scraper is always mocked in tests, ensuring deterministic input.
- The busy‑state flag prevents accidental double execution of routes.

In a production system, idempotency would require:

- stable primary keys,
- deduplication logic,
- and transactional writes.

Uniqueness Keys
---------------

Module 4 does not enforce uniqueness constraints because rows are stored
in a simple list. This design is intentional:

- The test suite controls all inserted rows.
- The scraper is mocked, so duplicates are not introduced unless a test
  explicitly creates them.
- The focus of the assignment is on ETL flow and route behavior, not
  database indexing.

In a real application, uniqueness keys would be defined at the database
layer (e.g., composite keys or UUIDs).

Troubleshooting
---------------

Local Issues
~~~~~~~~~~~~

**Sphinx import errors**

If Sphinx cannot import modules:

- Ensure ``conf.py`` adds the ``src`` directory to ``sys.path``.
- Verify that imports in ``app.py`` use absolute paths (e.g.,
  ``from load_data import get_all_rows``).

**Flask app not starting**

- Confirm the virtual environment is activated.
- Reinstall dependencies with ``pip install -r requirements.txt``.

**Tests failing due to stale state**

- Clear the in‑memory database by restarting the test session.
- Ensure no test mutates global state without resetting it.

CI Issues
~~~~~~~~~

**Import errors in GitHub Actions**

- Ensure the project structure matches the expected layout:
  ``src/`` for modules, ``tests/`` for tests.
- Confirm that ``pytest`` and ``sphinx`` are installed in the workflow.

**Sphinx warnings**

Warnings are acceptable, but duplicate module entries often indicate
that ``modules.rst`` or other autogenerated pages should be removed from
the toctree.

**Coverage not detected**

- Verify that ``--cov=src`` matches the actual module directory.
